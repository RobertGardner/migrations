{"version":3,"sources":["route_recognizer.js"],"names":[],"mappings":"AAAA,KAAO,EAAC,MAAK;AAAG,cAAY;AAAG,cAAY;AAAG,UAAQ;AAAG,cAAY,CAAC,KAAO,2BAAyB,CAAC;AACvG,KAAO,EAAC,GAAE;AAAG,WAAS;AAAG,KAAG;AAAG,YAAU;AAAG,UAAQ;AAAG,iBAAe,CAAC,KAAO,iCAA+B,CAAC;AAE9G,KAAO,EAAC,cAAa,CAAC,KAAO,oBAAkB,CAAC;AAMhD,KAAO,MAAM,gBAAc;AAKzB,YAAU,CAAE,AAAD,CAAG;AACZ,OAAG,MAAM,EAAI,CAAA,UAAS,OAAO,AAAC,EAAC,CAAC;AAChC,OAAG,SAAS,EAAI,CAAA,UAAS,OAAO,AAAC,EAAC,CAAC;AACnC,OAAG,UAAU,EAAI,CAAA,UAAS,OAAO,AAAC,EAAC,CAAC;EACtC;AAAA,AAEA,YAAU,CAAE,IAAG,AAAO,CAAG,CAAA,MAAK,AAAO,CAAS;AAC5C,aAAS,IAAI,AAAC,CAAC,IAAG,UAAU,CAAG,KAAG,CAAG,OAAK,CAAC,CAAC;EAC9C;AAAA,AAEA,UAAQ,CAAE,IAAG,AAAO,CAAG,CAAA,OAAM,AAAI,CAAG,CAAA,KAAI,EAAW,KAAG,CAAS;AAC7D,AAAI,MAAA,CAAA,UAAS,EAAI,IAAI,eAAa,AAAC,CAAC,IAAG,CAAG,QAAM,CAAC,CAAC;AAClD,aAAS,QAAQ,AAAC,CAAC,IAAG,SAAS,CAAG,EAAC,OAAM,CAAG,CAAA,CAAA,IAAM;AAChD,SAAI,UAAS,MAAM,SAAS,AAAC,EAAC,CAAA,EAAK,CAAA,OAAM,MAAM,SAAS,AAAC,EAAC,CAAG;AAC3D,YAAM,IAAI,cAAY,AAAC,CAAC,kBAAkB,IAAG,oCAAqC,OAAM,KAAK,GAAG,CAAC,CAAC;MACpG;AAAA,IACF,CAAC,CAAC;AACF,aAAS,IAAI,AAAC,CAAC,IAAG,SAAS,CAAG,CAAA,UAAS,MAAM,CAAG,WAAS,CAAC,CAAC;AAC3D,OAAI,SAAQ,AAAC,CAAC,KAAI,CAAC,CAAG;AACpB,eAAS,IAAI,AAAC,CAAC,IAAG,MAAM,CAAG,MAAI,CAAG,WAAS,CAAC,CAAC;IAC/C;AAAA,EACF;AAAA,AAOA,UAAQ,CAAE,GAAE,AAAO,CAAoB;AACrC,AAAI,MAAA,CAAA,SAAQ,EAAI,CAAA,WAAU,OAAO,AAAC,EAAC,CAAC;AAEpC,aAAS,QAAQ,AAAC,CAAC,IAAG,UAAU,CAAG,EAAC,MAAK,CAAG,CAAA,IAAG,IAAM;AAEnD,SAAI,aAAY,WAAW,AAAC,CAAC,GAAE,CAAG,KAAG,CAAC,CAAG;AACvC,UAAE,EAAI,CAAA,MAAK,EAAI,CAAA,aAAY,UAAU,AAAC,CAAC,GAAE,CAAG,CAAA,IAAG,OAAO,CAAC,CAAC;MAC1D;AAAA,IACF,CAAC,CAAC;AAEF,aAAS,QAAQ,AAAC,CAAC,IAAG,SAAS,CAAG,EAAC,cAAa,CAAG,CAAA,KAAI,IAAM;AAC3D,AAAI,QAAA,CAAA,KAAI,CAAC;AACT,SAAI,SAAQ,AAAC,CAAC,KAAI,EAAI,CAAA,aAAY,WAAW,AAAC,CAAC,KAAI,CAAG,IAAE,CAAC,CAAC,CAAG;AAE3D,AAAI,UAAA,CAAA,UAAS,EAAI,IAAE,CAAC;AACpB,AAAI,UAAA,CAAA,YAAW,EAAI,GAAC,CAAC;AACrB,WAAI,GAAE,GAAK,IAAE,CAAG;AACd,mBAAS,EAAI,CAAA,KAAI,CAAE,CAAA,CAAC,CAAC;AACrB,qBAAW,EAAI,CAAA,aAAY,UAAU,AAAC,CAAC,GAAE,CAAG,CAAA,KAAI,CAAE,CAAA,CAAC,OAAO,CAAC,CAAC;QAC9D;AAAA,AACA,kBAAU,KAAK,AAAC,CAAC,SAAQ,CAAG,IAAI,WAAS,AAAC,CAAC;AACzC,oBAAU,CAAG,CAAA,cAAa,YAAY;AACtC,gBAAM,CAAG,CAAA,cAAa,QAAQ;AAC9B,eAAK,CAAG,CAAA,cAAa,YAAY,AAAC,CAAC,GAAE,CAAC;AACtC,mBAAS,CAAG,WAAS;AACrB,qBAAW,CAAG,aAAW;AAAA,QAC3B,CAAC,CAAC,CAAC;MACL;AAAA,IACF,CAAC,CAAC;AAEF,SAAO,UAAQ,CAAC;EAClB;AAAA,AAEA,SAAO,CAAE,IAAG,AAAO,CAAY;AAC7B,SAAO,CAAA,UAAS,SAAS,AAAC,CAAC,IAAG,MAAM,CAAG,KAAG,CAAC,CAAC;EAC9C;AAAA,AAEA,SAAO,CAAE,IAAG,AAAO,CAAG,CAAA,MAAK,AAAI,CAAW;AACxC,AAAI,MAAA,CAAA,cAAa,EAAI,CAAA,UAAS,IAAI,AAAC,CAAC,IAAG,MAAM,CAAG,KAAG,CAAC,CAAC;AACrD,SAAO,CAAA,SAAQ,AAAC,CAAC,cAAa,CAAC,CAAA,CAAI,CAAA,cAAa,SAAS,AAAC,CAAC,MAAK,CAAC,CAAA,CAAI,KAAG,CAAC;EAC3E;AAAA,AACF;AAAA,AAnFA,KAAK,eAAe,AAAC,qDACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,YAD1B,MAAK,KAAgB,WAArB,MAAK,KAAgB,UAC4B;EAAC,CAAC,CAAC,CAAC;AADrD,KAAK,eAAe,AAAC,mDACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,YAD1B,MAAK,KAAgB,WAArB,MAAK,KAAgB,QAArB,MAAK,KAAgB,UAC4B;EAAC,CAAC,CAAC,CAAC;AADrD,KAAK,eAAe,AAAC,mDACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,YAD1B,MAAK,KAAgB,UAC4B;EAAC,CAAC,CAAC,CAAC;AADrD,KAAK,eAAe,AAAC,kDACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,YAD1B,MAAK,KAAgB,UAC4B;EAAC,CAAC,CAAC,CAAC;AADrD,KAAK,eAAe,AAAC,kDACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,YAD1B,MAAK,KAAgB,WAArB,MAAK,KAAgB,OAC4B;EAAC,CAAC,CAAC,CAAC;AAoFrD,KAAO,MAAM,WAAS;AAMpB,YAAU,CAAE,CAAC,WAAU;AAAG,UAAM;AAAG,SAAK;AAAG,aAAS;AAAG,eAAW,CAAC,EACmC,GAAC,CAAG;AAExG,OAAG,YAAY,EAAI,YAAU,CAAC;AAC9B,OAAG,QAAQ,EAAI,QAAM,CAAC;AACtB,OAAG,OAAO,EAAI,OAAK,CAAC;AACpB,OAAG,WAAW,EAAI,WAAS,CAAC;AAC5B,OAAG,aAAa,EAAI,aAAW,CAAC;EAClC;AAAA,AACF;AAAA","file":"angular2/src/router/route_recognizer.es6","sourcesContent":["import {RegExp, RegExpWrapper, StringWrapper, isPresent, BaseException} from 'angular2/src/facade/lang';\nimport {Map, MapWrapper, List, ListWrapper, StringMap, StringMapWrapper} from 'angular2/src/facade/collection';\n\nimport {PathRecognizer} from './path_recognizer';\n\n/**\n * `RouteRecognizer` is responsible for recognizing routes for a single component.\n * It is consumed by `RouteRegistry`, which knows how to recognize an entire hierarchy of components.\n */\nexport class RouteRecognizer {\n  names:Map<string, PathRecognizer>;\n  redirects:Map<string, string>;\n  matchers:Map<RegExp, PathRecognizer>;\n\n  constructor() {\n    this.names = MapWrapper.create();\n    this.matchers = MapWrapper.create();\n    this.redirects = MapWrapper.create();\n  }\n\n  addRedirect(path:string, target:string): void {\n    MapWrapper.set(this.redirects, path, target);\n  }\n\n  addConfig(path:string, handler:any, alias:string = null): void {\n    var recognizer = new PathRecognizer(path, handler);\n    MapWrapper.forEach(this.matchers, (matcher, _) => {\n      if (recognizer.regex.toString() == matcher.regex.toString()) {\n        throw new BaseException(`Configuration '${path}' conflicts with existing route '${matcher.path}'`);\n      }\n    });\n    MapWrapper.set(this.matchers, recognizer.regex, recognizer);\n    if (isPresent(alias)) {\n      MapWrapper.set(this.names, alias, recognizer);\n    }\n  }\n\n\n  /**\n   * Given a URL, returns a list of `RouteMatch`es, which are partial recognitions for some route.\n   *\n   */\n  recognize(url:string):List<RouteMatch> {\n    var solutions = ListWrapper.create();\n\n    MapWrapper.forEach(this.redirects, (target, path) => {\n      //TODO: \"/\" redirect case\n      if (StringWrapper.startsWith(url, path)) {\n        url = target + StringWrapper.substring(url, path.length);\n      }\n    });\n\n    MapWrapper.forEach(this.matchers, (pathRecognizer, regex) => {\n      var match;\n      if (isPresent(match = RegExpWrapper.firstMatch(regex, url))) {\n        //TODO(btford): determine a good generic way to deal with terminal matches\n        var matchedUrl = '/';\n        var unmatchedUrl = '';\n        if (url != '/') {\n          matchedUrl = match[0];\n          unmatchedUrl = StringWrapper.substring(url, match[0].length);\n        }\n        ListWrapper.push(solutions, new RouteMatch({\n          specificity: pathRecognizer.specificity,\n          handler: pathRecognizer.handler,\n          params: pathRecognizer.parseParams(url),\n          matchedUrl: matchedUrl,\n          unmatchedUrl: unmatchedUrl\n        }));\n      }\n    });\n\n    return solutions;\n  }\n\n  hasRoute(name:string): boolean {\n    return MapWrapper.contains(this.names, name);\n  }\n\n  generate(name:string, params:any): string {\n    var pathRecognizer = MapWrapper.get(this.names, name);\n    return isPresent(pathRecognizer) ? pathRecognizer.generate(params) : null;\n  }\n}\n\nexport class RouteMatch {\n  specificity:number;\n  handler:StringMap<string, any>;\n  params:StringMap<string, string>;\n  matchedUrl:string;\n  unmatchedUrl:string;\n  constructor({specificity, handler, params, matchedUrl, unmatchedUrl}:\n    {specificity:number, handler:StringMap, params:StringMap, matchedUrl:string, unmatchedUrl:string} = {}) {\n\n    this.specificity = specificity;\n    this.handler = handler;\n    this.params = params;\n    this.matchedUrl = matchedUrl;\n    this.unmatchedUrl = unmatchedUrl;\n  }\n}\n"]}