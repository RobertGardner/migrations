import {Promise,
  PromiseWrapper,
  EventEmitter,
  ObservableWrapper} from 'angular2/src/facade/async';
import {Map,
  MapWrapper,
  List,
  ListWrapper} from 'angular2/src/facade/collection';
import {isBlank,
  isPresent,
  Type} from 'angular2/src/facade/lang';
import {RouteRegistry} from './route_registry';
import {Pipeline} from './pipeline';
import {Instruction} from './instruction';
import {RouterOutlet} from './router_outlet';
import {Location} from './location';
export class Router {
  constructor(registry, pipeline, parent, hostComponent) {
    this.hostComponent = hostComponent;
    this.navigating = false;
    this.parent = parent;
    this.previousUrl = null;
    this._outlets = MapWrapper.create();
    this._registry = registry;
    this._pipeline = pipeline;
    this._subject = new EventEmitter();
    this._currentInstruction = null;
  }
  childRouter(hostComponent) {
    return new ChildRouter(this, hostComponent);
  }
  registerOutlet(outlet, name = 'default') {
    MapWrapper.set(this._outlets, name, outlet);
    if (isPresent(this._currentInstruction)) {
      var childInstruction = this._currentInstruction.getChild(name);
      return outlet.activate(childInstruction);
    }
    return PromiseWrapper.resolve(true);
  }
  config(config) {
    if (config instanceof List) {
      config.forEach((configObject) => {
        this._registry.config(this.hostComponent, configObject);
      });
    } else {
      this._registry.config(this.hostComponent, config);
    }
    return this.renavigate();
  }
  navigate(url) {
    if (this.navigating) {
      return PromiseWrapper.resolve(true);
    }
    this.lastNavigationAttempt = url;
    var matchedInstruction = this.recognize(url);
    if (isBlank(matchedInstruction)) {
      return PromiseWrapper.resolve(false);
    }
    if (isPresent(this._currentInstruction)) {
      matchedInstruction.reuseComponentsFrom(this._currentInstruction);
    }
    this._startNavigating();
    var result = this.commit(matchedInstruction).then((_) => {
      ObservableWrapper.callNext(this._subject, matchedInstruction.accumulatedUrl);
      this._finishNavigating();
    });
    PromiseWrapper.catchError(result, (_) => this._finishNavigating());
    return result;
  }
  _startNavigating() {
    this.navigating = true;
  }
  _finishNavigating() {
    this.navigating = false;
  }
  subscribe(onNext) {
    ObservableWrapper.subscribe(this._subject, onNext);
  }
  commit(instruction) {
    this._currentInstruction = instruction;
    var toDeactivate = ListWrapper.create();
    MapWrapper.forEach(this._outlets, (outlet, outletName) => {
      if (!instruction.hasChild(outletName)) {
        MapWrapper.delete(this._outlets, outletName);
        ListWrapper.push(toDeactivate, outlet);
      }
    });
    return PromiseWrapper.all(ListWrapper.map(toDeactivate, (outlet) => outlet.deactivate())).then((_) => this.activate(instruction));
  }
  deactivate() {
    return this._eachOutletAsync((outlet) => outlet.deactivate);
  }
  activate(instruction) {
    return this._eachOutletAsync((outlet, name) => outlet.activate(instruction.getChild(name)));
  }
  _eachOutletAsync(fn) {
    return mapObjAsync(this._outlets, fn);
  }
  recognize(url) {
    return this._registry.recognize(url, this.hostComponent);
  }
  renavigate() {
    var destination = isBlank(this.previousUrl) ? this.lastNavigationAttempt : this.previousUrl;
    if (this.navigating || isBlank(destination)) {
      return PromiseWrapper.resolve(false);
    }
    return this.navigate(destination);
  }
  generate(name, params) {
    return this._registry.generate(name, params, this.hostComponent);
  }
}
Object.defineProperty(Router, "parameters", {get: function() {
    return [[RouteRegistry], [Pipeline], [Router], [assert.type.any]];
  }});
Object.defineProperty(Router.prototype.childRouter, "parameters", {get: function() {
    return [[assert.type.any]];
  }});
Object.defineProperty(Router.prototype.registerOutlet, "parameters", {get: function() {
    return [[RouterOutlet], [assert.type.string]];
  }});
Object.defineProperty(Router.prototype.config, "parameters", {get: function() {
    return [[assert.type.any]];
  }});
Object.defineProperty(Router.prototype.navigate, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(Router.prototype.commit, "parameters", {get: function() {
    return [[Instruction]];
  }});
Object.defineProperty(Router.prototype.activate, "parameters", {get: function() {
    return [[Instruction]];
  }});
Object.defineProperty(Router.prototype.recognize, "parameters", {get: function() {
    return [[assert.type.string]];
  }});
Object.defineProperty(Router.prototype.generate, "parameters", {get: function() {
    return [[assert.type.string], [assert.genericType(StringMap, assert.type.string, assert.type.string)]];
  }});
export class RootRouter extends Router {
  constructor(registry, pipeline, location, hostComponent) {
    super(registry, pipeline, null, hostComponent);
    this._location = location;
    this._location.subscribe((change) => this.navigate(change['url']));
    this._registry.configFromComponent(hostComponent);
    this.navigate(location.path());
  }
  commit(instruction) {
    return super.commit(instruction).then((_) => {
      this._location.go(instruction.accumulatedUrl);
    });
  }
}
Object.defineProperty(RootRouter, "parameters", {get: function() {
    return [[RouteRegistry], [Pipeline], [Location], [Type]];
  }});
class ChildRouter extends Router {
  constructor(parent, hostComponent) {
    super(parent._registry, parent._pipeline, parent, hostComponent);
    this.parent = parent;
  }
}
Object.defineProperty(ChildRouter, "parameters", {get: function() {
    return [[Router], []];
  }});
function mapObjAsync(obj, fn) {
  return PromiseWrapper.all(mapObj(obj, fn));
}
Object.defineProperty(mapObjAsync, "parameters", {get: function() {
    return [[Map], []];
  }});
function mapObj(obj, fn) {
  var result = ListWrapper.create();
  MapWrapper.forEach(obj, (value, key) => ListWrapper.push(result, fn(value, key)));
  return result;
}
Object.defineProperty(mapObj, "parameters", {get: function() {
    return [[Map], []];
  }});
//# sourceMappingURL=router.js.map

//# sourceMappingURL=./router.map