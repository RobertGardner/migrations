{"version":3,"sources":["path_recognizer.js"],"names":[],"mappings":"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","file":"angular2/src/router/path_recognizer.es6","sourcesContent":["import {RegExp, RegExpWrapper, RegExpMatcherWrapper, StringWrapper, isPresent, isBlank, BaseException, normalizeBlank} from 'angular2/src/facade/lang';\nimport {Map, MapWrapper, StringMap, StringMapWrapper, List, ListWrapper} from 'angular2/src/facade/collection';\n\nimport {escapeRegex} from './url';\n\nclass StaticSegment {\n  string:string;\n  regex:string;\n  name:string;\n\n  constructor(string:string) {\n    this.string = string;\n    this.name = '';\n    this.regex = escapeRegex(string);\n  }\n\n  generate(params): string {\n    return this.string;\n  }\n}\n\nclass DynamicSegment {\n  name:string;\n  regex:string;\n  constructor(name:string) {\n    this.name = name;\n    this.regex = \"([^/]+)\";\n  }\n\n  generate(params:StringMap<string, string>): string {\n    if (!StringMapWrapper.contains(params, this.name)) {\n      throw new BaseException(`Route generator for '${this.name}' was not included in parameters passed.`)\n    }\n    return normalizeBlank(StringMapWrapper.get(params, this.name));\n  }\n}\n\n\nclass StarSegment {\n  name:string;\n  regex:string;\n  constructor(name:string) {\n    this.name = name;\n    this.regex = \"(.+)\";\n  }\n\n  generate(params:StringMap<string, string>): string {\n    return normalizeBlank(StringMapWrapper.get(params, this.name));\n  }\n}\n\n\nvar paramMatcher = RegExpWrapper.create(\"^:([^\\/]+)$\");\nvar wildcardMatcher = RegExpWrapper.create(\"^\\\\*([^\\/]+)$\");\n\nfunction parsePathString(route:string) {\n  // normalize route as not starting with a \"/\". Recognition will\n  // also normalize.\n  if (route[0] === \"/\") {\n    route = StringWrapper.substring(route, 1);\n  }\n\n  var segments = splitBySlash(route);\n  var results = ListWrapper.create();\n  var specificity = 0;\n\n  // The \"specificity\" of a path is used to determine which route is used when multiple routes match a URL.\n  // Static segments (like \"/foo\") are the most specific, followed by dynamic segments (like \"/:id\"). Star segments\n  // add no specificity. Segments at the start of the path are more specific than proceeding ones.\n  // The code below uses place values to combine the different types of segments into a single integer that we can\n  // sort later. Each static segment is worth hundreds of points of specificity (10000, 9900, ..., 200), and each\n  // dynamic segment is worth single points of specificity (100, 99, ... 2).\n  if (segments.length > 98) {\n    throw new BaseException(`'${route}' has more than the maximum supported number of segments.`);\n  }\n\n  for (var i=0; i<segments.length; i++) {\n    var segment = segments[i],\n        match;\n\n    if (isPresent(match = RegExpWrapper.firstMatch(paramMatcher, segment))) {\n      ListWrapper.push(results, new DynamicSegment(match[1]));\n      specificity += (100 - i);\n    } else if (isPresent(match = RegExpWrapper.firstMatch(wildcardMatcher, segment))) {\n      ListWrapper.push(results, new StarSegment(match[1]));\n    } else if (segment.length > 0) {\n      ListWrapper.push(results, new StaticSegment(segment));\n      specificity += 100 * (100 - i);\n    }\n  }\n\n  return {segments: results, specificity};\n}\n\nfunction splitBySlash (url:string):List<string> {\n  return url.split('/');\n}\n\n\n// represents something like '/foo/:bar'\nexport class PathRecognizer {\n  segments:List;\n  regex:RegExp;\n  handler:any;\n  specificity:number;\n  path:string;\n\n  constructor(path:string, handler:any) {\n    this.path = path;\n    this.handler = handler;\n    this.segments = [];\n\n    // TODO: use destructuring assignment\n    // see https://github.com/angular/ts2dart/issues/158\n    var parsed = parsePathString(path);\n    var specificity = parsed['specificity'];\n    var segments = parsed['segments'];\n    var regexString = '^';\n\n    ListWrapper.forEach(segments, (segment) => {\n      regexString += '/' + segment.regex;\n    });\n\n    this.regex = RegExpWrapper.create(regexString);\n    this.segments = segments;\n    this.specificity = specificity;\n  }\n\n  parseParams(url:string):StringMap<string, string> {\n    var params = StringMapWrapper.create();\n    var urlPart = url;\n    for(var i=0; i<this.segments.length; i++) {\n      var segment = this.segments[i];\n      var match = RegExpWrapper.firstMatch(RegExpWrapper.create('/' + segment.regex), urlPart);\n      urlPart = StringWrapper.substring(urlPart, match[0].length);\n      if (segment.name.length > 0) {\n        StringMapWrapper.set(params, segment.name, match[1]);\n      }\n    }\n\n    return params;\n  }\n\n  generate(params:StringMap<string, string>):string {\n    return ListWrapper.join(ListWrapper.map(this.segments, (segment) =>\n      '/' + segment.generate(params)), '');\n  }\n}\n"]}