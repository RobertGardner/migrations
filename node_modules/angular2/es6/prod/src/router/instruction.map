{"version":3,"sources":["instruction.js"],"names":[],"mappings":"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","file":"angular2/src/router/instruction.es6","sourcesContent":["import {Map, MapWrapper, StringMap, StringMapWrapper, List, ListWrapper} from 'angular2/src/facade/collection';\nimport {Promise, PromiseWrapper} from 'angular2/src/facade/async';\nimport {isPresent, normalizeBlank} from 'angular2/src/facade/lang';\n\nexport class RouteParams {\n  params:StringMap<string, string>;\n\n  constructor(params:StringMap) {\n    this.params = params;\n  }\n\n  get(param:string): string {\n    return normalizeBlank(StringMapWrapper.get(this.params, param));\n  }\n}\n\n/**\n * An `Instruction` represents the component hierarchy of the application based on a given route\n */\nexport class Instruction {\n  component:any;\n  _children:Map<string, Instruction>;\n\n  // the part of the URL captured by this instruction\n  capturedUrl:string;\n\n  // the part of the URL captured by this instruction and all children\n  accumulatedUrl:string;\n\n  params:StringMap<string, string>;\n  reuse:boolean;\n  specificity:number;\n\n  constructor({params, component, children, matchedUrl, parentSpecificity}:{params:StringMap, component:any, children:Map, matchedUrl:string, parentSpecificity:number} = {}) {\n    this.reuse = false;\n    this.capturedUrl = matchedUrl;\n    this.accumulatedUrl = matchedUrl;\n    this.specificity = parentSpecificity;\n    if (isPresent(children)) {\n      this._children = children;\n      var childUrl;\n      StringMapWrapper.forEach(this._children, (child, _) => {\n        childUrl = child.accumulatedUrl;\n        this.specificity += child.specificity;\n      });\n      if (isPresent(childUrl)) {\n        this.accumulatedUrl += childUrl;\n      }\n    } else {\n      this._children = StringMapWrapper.create();\n    }\n    this.component = component;\n    this.params = params;\n  }\n\n  hasChild(outletName:string):boolean {\n    return StringMapWrapper.contains(this._children, outletName);\n  }\n\n  /**\n   * Returns the child instruction with the given outlet name\n   */\n  getChild(outletName:string):Instruction {\n    return StringMapWrapper.get(this._children, outletName);\n  }\n\n  /**\n   * (child:Instruction, outletName:string) => {}\n   */\n  forEachChild(fn:Function): void {\n    StringMapWrapper.forEach(this._children, fn);\n  }\n\n  /**\n   * Does a synchronous, breadth-first traversal of the graph of instructions.\n   * Takes a function with signature:\n   * (child:Instruction, outletName:string) => {}\n   */\n  traverseSync(fn:Function): void {\n    this.forEachChild(fn);\n    this.forEachChild((childInstruction, _) => childInstruction.traverseSync(fn));\n  }\n\n\n  /**\n   * Takes a currently active instruction and sets a reuse flag on each of this instruction's children\n   */\n  reuseComponentsFrom(oldInstruction:Instruction): void {\n    this.traverseSync((childInstruction, outletName) => {\n      var oldInstructionChild = oldInstruction.getChild(outletName);\n      if (shouldReuseComponent(childInstruction, oldInstructionChild)) {\n        childInstruction.reuse = true;\n      }\n    });\n  }\n}\n\nfunction shouldReuseComponent(instr1:Instruction, instr2:Instruction): boolean {\n  return instr1.component == instr2.component &&\n    StringMapWrapper.equals(instr1.params, instr2.params);\n}\n\nfunction mapObjAsync(obj:StringMap, fn): Promise {\n  return PromiseWrapper.all(mapObj(obj, fn));\n}\n\nfunction mapObj(obj:StringMap, fn: Function):List {\n  var result = ListWrapper.create();\n  StringMapWrapper.forEach(obj, (value, key) => ListWrapper.push(result, fn(value, key)));\n  return result;\n}\n"]}