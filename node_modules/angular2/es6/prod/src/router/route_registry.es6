import {RouteRecognizer,
  RouteMatch} from './route_recognizer';
import {Instruction,
  noopInstruction} from './instruction';
import {List,
  ListWrapper,
  Map,
  MapWrapper,
  StringMap,
  StringMapWrapper} from 'angular2/src/facade/collection';
import {isPresent,
  isBlank,
  isType,
  StringWrapper,
  BaseException} from 'angular2/src/facade/lang';
import {RouteConfig} from './route_config_impl';
import {reflector} from 'angular2/src/reflection/reflection';
export class RouteRegistry {
  constructor() {
    this._rules = MapWrapper.create();
  }
  config(parentComponent, config) {
    if (!StringMapWrapper.contains(config, 'path')) {
      throw new BaseException('Route config does not contain "path"');
    }
    if (!StringMapWrapper.contains(config, 'component') && !StringMapWrapper.contains(config, 'components') && !StringMapWrapper.contains(config, 'redirectTo')) {
      throw new BaseException('Route config does not contain "component," "components," or "redirectTo"');
    }
    var recognizer = MapWrapper.get(this._rules, parentComponent);
    if (isBlank(recognizer)) {
      recognizer = new RouteRecognizer();
      MapWrapper.set(this._rules, parentComponent, recognizer);
    }
    config = normalizeConfig(config);
    if (StringMapWrapper.contains(config, 'redirectTo')) {
      recognizer.addRedirect(config['path'], config['redirectTo']);
      return ;
    }
    var components = config['components'];
    StringMapWrapper.forEach(components, (component, _) => this.configFromComponent(component));
    recognizer.addConfig(config['path'], config, config['as']);
  }
  configFromComponent(component) {
    if (!isType(component)) {
      return ;
    }
    if (MapWrapper.contains(this._rules, component)) {
      return ;
    }
    var annotations = reflector.annotations(component);
    if (isPresent(annotations)) {
      for (var i = 0; i < annotations.length; i++) {
        var annotation = annotations[i];
        if (annotation instanceof RouteConfig) {
          ListWrapper.forEach(annotation.configs, (config) => this.config(component, config));
        }
      }
    }
  }
  recognize(url, parentComponent) {
    var componentRecognizer = MapWrapper.get(this._rules, parentComponent);
    if (isBlank(componentRecognizer)) {
      return null;
    }
    var possibleMatches = componentRecognizer.recognize(url);
    var fullSolutions = ListWrapper.create();
    for (var i = 0; i < possibleMatches.length; i++) {
      var candidate = possibleMatches[i];
      if (candidate.unmatchedUrl.length == 0) {
        ListWrapper.push(fullSolutions, routeMatchToInstruction(candidate, parentComponent));
      } else {
        var children = StringMapWrapper.create(),
            allChildrenMatch = true,
            components = StringMapWrapper.get(candidate.handler, 'components');
        var componentNames = StringMapWrapper.keys(components);
        for (var nameIndex = 0; nameIndex < componentNames.length; nameIndex++) {
          var name = componentNames[nameIndex];
          var component = StringMapWrapper.get(components, name);
          var childInstruction = this.recognize(candidate.unmatchedUrl, component);
          if (isPresent(childInstruction)) {
            childInstruction.params = candidate.params;
            children[name] = childInstruction;
          } else {
            allChildrenMatch = false;
            break;
          }
        }
        if (allChildrenMatch) {
          ListWrapper.push(fullSolutions, new Instruction({
            component: parentComponent,
            children: children,
            matchedUrl: candidate.matchedUrl,
            parentSpecificity: candidate.specificity
          }));
        }
      }
    }
    if (fullSolutions.length > 0) {
      var mostSpecificSolution = fullSolutions[0];
      for (var solutionIndex = 1; solutionIndex < fullSolutions.length; solutionIndex++) {
        var solution = fullSolutions[solutionIndex];
        if (solution.specificity > mostSpecificSolution.specificity) {
          mostSpecificSolution = solution;
        }
      }
      return mostSpecificSolution;
    }
    return null;
  }
  generate(name, params, hostComponent) {
    var componentRecognizer = MapWrapper.get(this._rules, hostComponent);
    return isPresent(componentRecognizer) ? componentRecognizer.generate(name, params) : null;
  }
}
Object.defineProperty(RouteRegistry.prototype.config, "parameters", {get: function() {
    return [[], [assert.genericType(StringMap, assert.type.string, assert.type.any)]];
  }});
Object.defineProperty(RouteRegistry.prototype.recognize, "parameters", {get: function() {
    return [[assert.type.string], []];
  }});
Object.defineProperty(RouteRegistry.prototype.generate, "parameters", {get: function() {
    return [[assert.type.string], [assert.genericType(StringMap, assert.type.string, assert.type.string)], []];
  }});
function routeMatchToInstruction(routeMatch, parentComponent) {
  var children = StringMapWrapper.create();
  var components = StringMapWrapper.get(routeMatch.handler, 'components');
  StringMapWrapper.forEach(components, (component, outletName) => {
    children[outletName] = new Instruction({
      component: component,
      params: routeMatch.params,
      parentSpecificity: 0
    });
  });
  return new Instruction({
    component: parentComponent,
    children: children,
    matchedUrl: routeMatch.matchedUrl,
    parentSpecificity: routeMatch.specificity
  });
}
Object.defineProperty(routeMatchToInstruction, "parameters", {get: function() {
    return [[RouteMatch], []];
  }});
function normalizeConfig(config) {
  if (!StringMapWrapper.contains(config, 'component')) {
    return config;
  }
  var newConfig = {'components': {'default': config['component']}};
  StringMapWrapper.forEach(config, (value, key) => {
    if (key != 'component' && key != 'components') {
      newConfig[key] = value;
    }
  });
  return newConfig;
}
Object.defineProperty(normalizeConfig, "parameters", {get: function() {
    return [[assert.genericType(StringMap, assert.type.string, assert.type.any)]];
  }});
//# sourceMappingURL=route_registry.js.map

//# sourceMappingURL=./route_registry.map