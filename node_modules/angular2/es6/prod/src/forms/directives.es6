var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Directive, Ancestor } from 'angular2/src/core/annotations/decorators';
import { Optional } from 'angular2/src/di/decorators';
import { ElementRef } from 'angular2/src/core/compiler/element_ref';
import { Renderer } from 'angular2/src/render/api';
import { isPresent, CONST_EXPR, isBlank, BaseException } from 'angular2/src/facade/lang';
import { ListWrapper } from 'angular2/src/facade/collection';
import { isControl } from './model';
import { Validators } from './validators';
function _lookupControl(groupDirective, controlOrName) {
    if (isControl(controlOrName)) {
        return controlOrName;
    }
    if (isBlank(groupDirective)) {
        throw new BaseException(`No control group found for "${controlOrName}"`);
    }
    var control = groupDirective.findControl(controlOrName);
    if (isBlank(control)) {
        throw new BaseException(`Cannot find control "${controlOrName}"`);
    }
    return control;
}
/**
 * Binds a control group to a DOM element.
 *
 * # Example
 *
 * In this example, we bind the control group to the form element, and we bind the login and
 * password controls to the
 * login and password elements.
 *
 * Here we use {@link formDirectives}, rather than importing each form directive individually, e.g.
 * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.
 *
 *  ```
 * @Component({selector: "login-comp"})
 * @View({
 *      directives: [formDirectives],
 *      inline: "<form [control-group]='loginForm'>" +
 *              "Login <input type='text' control='login'>" +
 *              "Password <input type='password' control='password'>" +
 *              "<button (click)="onLogin()">Login</button>" +
 *              "</form>"
 *      })
 * class LoginComp {
 *  loginForm:ControlGroup;
 *
 *  constructor() {
 *    this.loginForm = new ControlGroup({
 *      login: new Control(""),
 *      password: new Control("")
 *    });
 *  }
 *
 *  onLogin() {
 *    // this.loginForm.value
 *  }
 * }
 *
 *  ```
 *
 * @exportedAs angular2/forms
 */
export let ControlGroupDirective = class {
    constructor(groupDirective) {
        this._groupDirective = groupDirective;
        this._directives = ListWrapper.create();
    }
    set controlOrName(controlOrName) {
        this._controlOrName = controlOrName;
        this._updateDomValue();
    }
    _updateDomValue() { ListWrapper.forEach(this._directives, (cd) => cd._updateDomValue()); }
    addDirective(c) { ListWrapper.push(this._directives, c); }
    findControl(name) { return this._getControlGroup().controls[name]; }
    _getControlGroup() {
        return _lookupControl(this._groupDirective, this._controlOrName);
    }
};
ControlGroupDirective = __decorate([
    Directive({ selector: '[control-group]', properties: { 'controlOrName': 'control-group' } }),
    __param(0, Optional()),
    __param(0, Ancestor()), 
    __metadata('design:paramtypes', [ControlGroupDirective])
], ControlGroupDirective);
/**
 * Binds a control to a DOM element.
 *
 * # Example
 *
 * In this example, we bind the control to an input element. When the value of the input element
 * changes, the value of
 * the control will reflect that change. Likewise, if the value of the control changes, the input
 * element reflects that
 * change.
 *
 * Here we use {@link formDirectives}, rather than importing each form directive individually, e.g.
 * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.
 *
 *  ```
 * @Component({selector: "login-comp"})
 * @View({
 *      directives: [formDirectives],
 *      inline: "<input type='text' [control]='loginControl'>"
 *      })
 * class LoginComp {
 *  loginControl:Control;
 *
 *  constructor() {
 *    this.loginControl = new Control('');
 *  }
 * }
 *
 *  ```
 *
 * @exportedAs angular2/forms
 */
export let ControlDirective = class {
    constructor(groupDirective) {
        this._groupDirective = groupDirective;
        this._controlOrName = null;
        this.validator = Validators.nullValidator;
    }
    set controlOrName(controlOrName) {
        this._controlOrName = controlOrName;
        if (isPresent(this._groupDirective)) {
            this._groupDirective.addDirective(this);
        }
        var c = this._control();
        c.validator = Validators.compose([c.validator, this.validator]);
        if (isBlank(this.valueAccessor)) {
            throw new BaseException(`Cannot find value accessor for control "${controlOrName}"`);
        }
        this._updateDomValue();
        this._setUpUpdateControlValue();
    }
    _updateDomValue() { this.valueAccessor.writeValue(this._control().value); }
    _setUpUpdateControlValue() {
        this.valueAccessor.onChange = (newValue) => this._control().updateValue(newValue);
    }
    _control() { return _lookupControl(this._groupDirective, this._controlOrName); }
};
ControlDirective = __decorate([
    Directive({ selector: '[control]', properties: { 'controlOrName': 'control' } }),
    __param(0, Optional()),
    __param(0, Ancestor()), 
    __metadata('design:paramtypes', [ControlGroupDirective])
], ControlDirective);
/**
 * The default accessor for writing a value and listening to changes that is used by a {@link
  * Control} directive.
 *
 * This is the default strategy that Angular uses when no other accessor is applied.
 *
 *  # Example
 *  ```
 *  <input type="text" [control]="loginControl">
 *  ```
 *
 * @exportedAs angular2/forms
 */
export let DefaultValueAccessor = class {
    constructor(cd, _elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.value = null;
        this.onChange = (_) => { };
        cd.valueAccessor = this;
    }
    writeValue(value) {
        this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, 'value', value);
    }
};
DefaultValueAccessor = __decorate([
    Directive({
        selector: 'input:not([type=checkbox])[control],textarea[control]',
        hostListeners: { 'change': 'onChange($event.target.value)', 'input': 'onChange($event.target.value)' },
        hostProperties: { 'value': 'value' }
    }), 
    __metadata('design:paramtypes', [ControlDirective, ElementRef, Renderer])
], DefaultValueAccessor);
/**
 * The accessor for writing a value and listening to changes that is used by a {@link
  * Control} directive.
 *
 * This is the default strategy that Angular uses when no other accessor is applied.
 *
 *  # Example
 *  ```
 *  <input type="text" [control]="loginControl">
 *  ```
 *
 * @exportedAs angular2/forms
 */
export let SelectControlValueAccessor = class {
    constructor(cd, _elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.value = null;
        this.onChange = (_) => { };
        this.value = '';
        cd.valueAccessor = this;
    }
    writeValue(value) {
        this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, 'value', value);
    }
};
SelectControlValueAccessor = __decorate([
    Directive({
        selector: 'select[control]',
        hostListeners: { 'change': 'onChange($event.target.value)', 'input': 'onChange($event.target.value)' },
        hostProperties: { 'value': 'value' }
    }), 
    __metadata('design:paramtypes', [ControlDirective, ElementRef, Renderer])
], SelectControlValueAccessor);
/**
 * The accessor for writing a value and listening to changes on a checkbox input element.
 *
 *
 *  # Example
 *  ```
 *  <input type="checkbox" [control]="rememberLogin">
 *  ```
 *
 * @exportedAs angular2/forms
 */
export let CheckboxControlValueAccessor = class {
    constructor(cd, _elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.onChange = (_) => { };
        cd.valueAccessor = this;
    }
    writeValue(value) {
        this._renderer.setElementProperty(this._elementRef.parentView.render, this._elementRef.boundElementIndex, 'checked', value);
    }
};
CheckboxControlValueAccessor = __decorate([
    Directive({
        selector: 'input[type=checkbox][control]',
        hostListeners: { 'change': 'onChange($event.target.checked)' },
        hostProperties: { 'checked': 'checked' }
    }), 
    __metadata('design:paramtypes', [ControlDirective, ElementRef, Renderer])
], CheckboxControlValueAccessor);
/**
 *
 * A list of all the form directives used as part of a `@View` annotation.
 *
 *  This is a shorthand for importing them each individually.
 *
 * @exportedAs angular2/forms
 */
export const formDirectives = CONST_EXPR([
    ControlGroupDirective,
    ControlDirective,
    CheckboxControlValueAccessor,
    DefaultValueAccessor,
    SelectControlValueAccessor
]);
//# sourceMappingURL=directives.js.map